import { z } from 'zod';
import { publicProcedure, router } from '../trpc';
import { supabase } from '@/lib/supabase';

export const workflowRouter = router({
  list: publicProcedure
    .input(z.object({ userId: z.string().uuid() }).optional())
    .query(async ({ input }) => {
      // In a real app, get userId from session. For now, use the seed user or input.
      const targetUser = input?.userId || 'cb176b48-0995-41e2-8dda-2b80b29cb94d'; 
      
      const { data, error } = await supabase
        .from('workflows')
        .select('*')
        .eq('user_id', targetUser)
        .order('created_at', { ascending: false });

      if (error) throw new Error(error.message);
      return data;
    }),

  get: publicProcedure
    .input(z.object({ id: z.string().uuid() }))
    .query(async ({ input }) => {
      const { data, error } = await supabase
        .from('workflows')
        .select('*, agents(*), workflow_connections(*)')
        .eq('id', input.id)
        .single();
        
      if (error) throw new Error(error.message);
      return data;
    }),

  create: publicProcedure
    .input(z.object({ 
      userId: z.string().uuid(),
      name: z.string(),
      description: z.string().optional()
    }))
    .mutation(async ({ input }) => {
      const { data, error } = await supabase
        .from('workflows')
        .insert({
          user_id: input.userId,
          name: input.name,
          description: input.description
        })
        .select()
        .single();
        
      if (error) throw new Error(error.message);
      return data;
    }),

  saveGraph: publicProcedure
    .input(z.object({
      workflowId: z.string().uuid(),
      agents: z.array(z.object({
        id: z.string().optional(), // Optional for new agents
        name: z.string(),
        role: z.string(),
        model: z.string(),
        system_instructions: z.string(),
        tools: z.array(z.string()).optional()
      })),
      connections: z.array(z.object({
        from_agent_id: z.string().nullable(),
        to_agent_id: z.string()
      }))
    }))
    .mutation(async ({ input }) => {
      // 1. Upsert Agents
      // We need to handle new agents (no ID) and existing ones.
      // Supabase upsert needs ID to match.
      
      const agentsToUpsert = input.agents.map(a => ({
        id: a.id, // If undefined, Supabase generic insert might fail if we don't separate insert/update
        // Actually, best to generate UUIDs on client for ReactFlow nodes, 
        // OR separate insert vs update. 
        // Client-side UUID generation is easier for graph editors.
        // Let's assume input.agents ALREADY has IDs (generated by frontend).
        workflow_id: input.workflowId,
        name: a.name,
        role: a.role,
        model: a.model,
        system_instructions: a.system_instructions,
        tools: a.tools || []
      }));

      const { error: agentsError } = await supabase
        .from('agents')
        .upsert(agentsToUpsert, { onConflict: 'id' });
        
      if (agentsError) throw new Error("Agent Error: " + agentsError.message);

      // 2. Sync Connections
      // Simplest strategy: Delete all for this workflow, re-insert.
      await supabase.from('workflow_connections').delete().eq('workflow_id', input.workflowId);

      const connsToInsert = input.connections.map(c => ({
        workflow_id: input.workflowId,
        from_agent_id: c.from_agent_id,
        to_agent_id: c.to_agent_id
      }));
      
      if (connsToInsert.length > 0) {
        const { error: connsError } = await supabase
          .from('workflow_connections')
          .insert(connsToInsert);
          
        if (connsError) throw new Error("Connection Error: " + connsError.message);
      }

      return { success: true };
    }),
});
